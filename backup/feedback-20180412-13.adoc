= 2018.04.12 - 2018.04.13

=== 질문

===== 내가 한 질문
* TDD를 통해 비즈니스 로직을 검증할 때 TDD가 잘못된 경우는 어떻게 판단하나요?
* ATDD?
* TDD와 유닛테스트 차이
* 이러한 과정들이 나온 배경

===== 전체 질문
* 개념 정의
* TDD 실제 사례, 왜 널리 퍼지지 못했나?
* 단위 테스트 하기 좋은 설계 구조
* 단위 테스트가 유효한 케이스
* TDD 베이스가 없을 때 리팩토링, TDD 어떻게 해야할까?
* 리팩토링 혼자서 연습하는 부분

=== 2018.04.12 수업 내용

===== 코드 스멜
* 코드를 관찰하고 이상한 부분을 느낌. 직관을 찾는 훈련. 왜 불편하지 ?
** 관찰 -> 느낌 -> 생각
* 하드코딩된 문자나 숫자가 의미 있는 상수, 변수로 선언
* 메서드 추출. Composed Method Pattern
** 추상화 수준이 다르면 읽기 힘들어짐
** 동작에게 이름을 부여함
* 예외 케이스를 빨리 처리하면 됨. 예외 case return 
** Guard clause
* 긴 메서드

===== 리팩토링 골프
* 이클립스 
** cmd + 1
** cmd + space
** Refactor History
* 인텔리제이
** cmd + option + m
** cmd + option + c
** option + enter 
** ctrl + T
* 개발자는
** 툴에서 리팩토링 기능을 많이 지원함
** 프로그래머는 기능구현이 끝난 다음에 좋은 설계에 집중해야 함
* TDD를 잘한다고 설계를 잘하는 것이 아님. TDD보다 좋은 설계 경험이 있어야 함. 리팩토링을 잘해야 함

===== 좋은 코드를 매일 판별해야 하나 ? 기준이나 관점을 가지면 됨
* 코멘트 => 코드에는 What, How는 있지만 Why가 없음
** What => 잘 지은 변수명
** How => 코드로 읽으면 됨
** 코멘트가 왜 코드 스멜인가? => 처음에 작성한 코드와 주석은 맞았지만 시간이 지난 후, 코드와 주석 불일치하는 경우가 발생함
** 코멘트를 달 때 Why? 인지 판단을 해야 함
* Oddball Solution
** 동일한 기능을 여러 패턴로 구현되어 있음. 동일한 기능을 하는 것은 한 패턴으로 구현되어 있어야 하는 것이 정상
* Primitive Obsession
** 전화번호 확인할 경우, String으로 처리함
** 클래스 타입으로 빼는 것이 좋음

[source, java]
----
public class List {
	private Object[] elements = new Object[10];
	private boolean readOnly;
	private int size = 0;

	public void add(Object element) {
		if (!readOnly) {
			int newSize = size + 1;
			
			if ( newSize > elements.length) {
				Object[] newElements = new Object[elements.length + 10];
				for (int i = 0; i < size; i++) {
					newElements[i] = elements[i];
				}

				elements = newElements;
			}

			elements[size] = element;
			size++;
		}
	}

	public int size() {
		return size;
	}

	public Object get(int index) {
		return elements[index];
	}
}


import static org.hamcrest.Matchers.is;
import static org.junit.Assert.assertThat;
import org.junit.Test;
import original.List;

public class ListTest {
	List list = new List();
	
	@Test
	public void initial_size_should_be_zero() {
		assertThat(list.size(),is(0));
	}
	
	@Test
	public void size_should_increase_by_1_when_an_element_is_added() {
		list.add("I");
		
		assertThat(list.size(),is(1));
	}
	
	@Test
	public void element_should_be_at_0_when_a_first_element_is_added() {
		list.add("1");
		
		assertThat(list.get(0).toString(),is("1"));
	}
	
	@Test
	public void element_should_be_at_1_when_a_second_element_is_added() {
		list.add("1");
		list.add("2");
		
		assertThat(list.get(1).toString(),is("2"));
	}
	
	
	@Test
	public void add_element_() {
		list.add("1");
		list.add("2");
		list.add("3");
		list.add("4");
		list.add("5");
		list.add("6");
		list.add("7");
		list.add("8");
		list.add("9");
		list.add("10");
		
		list.add("11");
		
		assertThat(list.get(10).toString(),is("11"));
	}
}
----