= 2018.04.12 - 2018.04.13

=== 질문

===== 내가 한 질문
* TDD를 통해 비즈니스 로직을 검증할 때 TDD가 잘못된 경우는 어떻게 판단하나요?
* ATDD?
* TDD와 유닛테스트 차이
* 이러한 과정들이 나온 배경

===== 전체 질문
* 개념 정의
* TDD 실제 사례, 왜 널리 퍼지지 못했나?
* 단위 테스트 하기 좋은 설계 구조
* 단위 테스트가 유효한 케이스
* TDD 베이스가 없을 때 리팩토링, TDD 어떻게 해야할까?
* 리팩토링 혼자서 연습하는 부분

=== 2018.04.12 수업 내용

===== 코드 스멜
* 코드를 관찰하고 이상한 부분을 느낌. 직관을 찾는 훈련. 왜 불편하지 ?
** 관찰 -> 느낌 -> 생각
* 하드코딩된 문자나 숫자가 의미 있는 상수, 변수로 선언
* 메서드 추출. Composed Method Pattern
** 추상화 수준이 다르면 읽기 힘들어짐
** 동작에게 이름을 부여함
* 예외 케이스를 빨리 처리하면 됨. 예외 case return 
** Guard clause
* 긴 메서드

===== 리팩토링 골프
* 이클립스 
** cmd + 1
** cmd + space
** Refactor History
* 인텔리제이
** cmd + option + m
** cmd + option + c
** option + enter 
** ctrl + T
* 개발자는
** 툴에서 리팩토링 기능을 많이 지원함
** 프로그래머는 기능구현이 끝난 다음에 좋은 설계에 집중해야 함
* TDD를 잘한다고 설계를 잘하는 것이 아님. TDD보다 좋은 설계 경험이 있어야 함. 리팩토링을 잘해야 함

===== 좋은 코드를 매일 판별해야 하나 ? 기준이나 관점을 가지면 됨
* 코멘트 => 코드에는 What, How는 있지만 Why가 없음
** What => 잘 지은 변수명
** How => 코드로 읽으면 됨
** 코멘트가 왜 코드 스멜인가? => 처음에 작성한 코드와 주석은 맞았지만 시간이 지난 후, 코드와 주석 불일치하는 경우가 발생함
** 코멘트를 달 때 Why? 인지 판단을 해야 함
* Oddball Solution
** 동일한 기능을 여러 패턴로 구현되어 있음. 동일한 기능을 하는 것은 한 패턴으로 구현되어 있어야 하는 것이 정상
* Primitive Obsession
** 전화번호 확인할 경우, String으로 처리함
** 클래스 타입으로 빼는 것이 좋음

[source, java]
----
// 리팩토링 되기 전
public class List {
	private Object[] elements = new Object[10];
	private boolean readOnly;
	private int size = 0;

	public void add(Object element) {
		if (!readOnly) {
			int newSize = size + 1;
			
			if ( newSize > elements.length) {
				Object[] newElements = new Object[elements.length + 10];
				for (int i = 0; i < size; i++) {
					newElements[i] = elements[i];
				}

				elements = newElements;
			}

			elements[size] = element;
			size++;
		}
	}

	public int size() {
		return size;
	}

	public Object get(int index) {
		return elements[index];
	}
}


import static org.hamcrest.Matchers.is;
import static org.junit.Assert.assertThat;
import org.junit.Test;
import original.List;

public class ListTest {
	List list = new List();
	
	@Test
	public void initial_size_should_be_zero() {
		assertThat(list.size(),is(0));
	}
	
	@Test
	public void size_should_increase_by_1_when_an_element_is_added() {
		list.add("I");
		
		assertThat(list.size(),is(1));
	}
	
	@Test
	public void element_should_be_at_0_when_a_first_element_is_added() {
		list.add("1");
		
		assertThat(list.get(0).toString(),is("1"));
	}
	
	@Test
	public void element_should_be_at_1_when_a_second_element_is_added() {
		list.add("1");
		list.add("2");
		
		assertThat(list.get(1).toString(),is("2"));
	}
	
	
	@Test
	public void add_element_() {
		list.add("1");
		list.add("2");
		list.add("3");
		list.add("4");
		list.add("5");
		list.add("6");
		list.add("7");
		list.add("8");
		list.add("9");
		list.add("10");
		
		list.add("11");
		
		assertThat(list.get(10).toString(),is("11"));
	}
}
----

===== TDD가 쉽잖아. 하지만 잘 안됨
* Backward byicycle 
** 뇌 회로가 빨리 형성이 되어야 함. 일반적으로 한달 정도 걸림
** 어른은 시간이 걸리지만 어린이는 빠름
* TDD도 말처럼 쉽지만, 습관이 되기 위해서 최소 핟날이 걸림
* 이틀 들어서 TDD가 되지 않음. 결국 수련이 필요함
* 변화하고 싶으면 뇌 회로가 생겨야 함

====== 마틴파울러 리팩토링 1장
* 코드 스멜을 찾는 방법
* 단위 테스트를 작성하는 방법
* 레거시 코드를 리팩토링을 하는 방법
* 툴을 이용한 리랙토링 자동화를 사용하는 방법
* 클린 코드를 작성하는 방법
** Eclipse => eclEmma Java Code Coverage 2.3.2

===== 리팩토링 전제 조건
* 외부 동작을 바꾸지 않으면서 내부 구조를 개선하는 것
* 코드를 변경했을 때, 외부 동작이 바뀌지 않았다는 것을 증명해야 함
* 소프트웨어 요구사항이 들어오면 내가 해야할 일을 다른 사람에게 넘겼을 때 발생함

===== 레거시 코드 단위 테스트 작성하기
* 생성자 테스트 작성하기
* 테스트 커버리지를 측정함
* 테스트 되지 않은 코드를 커버할 수 있는 새로운 테스트를 작성함(= Characterization Test)
* 테스트 커버리지가 100%에 가까워질 때까지 테스트 코드를 작성함
* Characterization Test
** 코드를 이해하고 짜는 것이 아니라 레거시 코드에 대한 테스트를 작성하면서 레거시 코드를 이해함
* IntelliJ => cmd + shift + t

===== 생성자 테스트 작성하기
* 목적 : 객체 생성 비용을 파악함
* JUnit test Class를 생성함
* 테스트 메서드 이름을 testCreate 라고 함
* Customer 클래스의 객체를 생성함
* 테스트함
** ctrl + space => 자동완성
** ctrl + shift + r => 테스트 실행
** 인텔리제이 커버리지 확인 => Run function name with Coverage
** org.junit.ComparisonFailure:  <Click to see difference>
** addRental 할 때 그때서야 분석이 필요함
** 라인 커버리지도 존재하며, 브랜치 커버리지도 존재함. 각각 상황에 대한 커버리지가 존재함
** eclEmma Java Code Coverage 2.3.2는 Complexity 커버리지를 확인할 수 있음. Complexity 커버리지를 보는 것이 좋음
** 입력 데이터를 만드려고 하는 것이 아니라 null도 넣어보고 다양한 형태로 하면 됨:)
** 테스트 케이스 5줄 이내 작성하는 것이 좋음
** 매개변수로 인라인 작성보다 새로운 변수로 만들고 테스트 케이스 작성하는 것이 좋음
** IntelliJ Tip 
*** Color Scheme > General > Line Coverage > Foreground 같은 색깔로 Background 설정하고 Foreground 선택 해제
** JUnit에서 전역변수로 사용할 때 테스트 값을 공유하는 것인가 ? 개별적으로 인스턴스를 만드는가 ?
*** @Before setUp(), @After tearDown()
** 코드 중복을 없애야 함. 추상화를 해야 함 => 메서드 이름이 필요함 => 이름을 짓는 순간 추상화를 하는 것임
** 테스트 코드도 제품 코드에 의존적일 수 밖에 없음. 최대한 중복을 피하고 한 곳에서만 수정할 수 있게 테스트코드도 리팩토링이 필요함
** 중요한 것을 앞으로 뺌
** 실무에서 연습할 때 혼자서 연습할 때....
*** CodeKata
*** 같은 스탭을 여러 번 익혀봄
** Validation은 경계값에서 해야 함. 그래서 테스트는 비지니스 로직만 남겨두는 것이 거의 좋음
*** Complexity Coverages 100%를 가져가야 함
*** 그러나, 세상에 정답이 있는 문제는 많지 않음
*** 커뮤니케이션이 되지 않아서 백단에서도 제품 로직에 단순한 유효성 검사가 들어간다면 그거에 대한 테스트 코드가 필요함
*** Loop가 있다면 적어도 2번 이상은 돌려서 누적되는 값을 확인해야 함

[source, java]
----
// Before
public class CustomerTest {
    public static final String TITLE = "비디오";
    public static final int TWO_DAYS = 2;
    public static final int THREE_DAYS = 3;

    // 이름을 중요하지 않음
    String name= "NAME_NOT_IMPORTANT";
    Customer customer = new Customer(name);
    public static final int REGULAR = 0;
    public static final int NEW_RELEASE = 1;
    public static final int CHILDRENS = 2;

    @Before
    public void setUp() {
        System.out.println("setUp Object: " + this);
    }

    @After
    public void tearDown() {
        System.out.println("tearDown Object: " + this);
    }

    @Test
    public void test_객체_생성() {
        String statement = customer.statement();

        assertEquals("Rental Record for NAME_NOT_IMPORTANT\n" +
                "Amount owed is 0.0\n" +
                "You earned 0 frequent renter pointers", statement);
    }

    @Test
    public void statement_regular_2일초과() {
        String statement = createRentalFor(TWO_DAYS, REGULAR);

        assertEquals("Rental Record for NAME_NOT_IMPORTANT\n" +
                "\t2.0(비디오)\n" +
                "Amount owed is 2.0\n" +
                "You earned 1 frequent renter pointers", statement);
    }

    @Test
    public void statement_regular_3일초과() {
        String statement = createRentalFor(THREE_DAYS, REGULAR);

        assertEquals("Rental Record for NAME_NOT_IMPORTANT\n" +
                "\t3.5(비디오)\n" +
                "Amount owed is 3.5\n" +
                "You earned 1 frequent renter pointers", statement);
    }

    @Test
    public void statement_newRelease_3일초과() {
        String statement = createRentalFor(THREE_DAYS, NEW_RELEASE);

        assertEquals("Rental Record for NAME_NOT_IMPORTANT\n" +
                "\t9.0(비디오)\n" +
                "Amount owed is 9.0\n" +
                "You earned 2 frequent renter pointers", statement);
    }

    @Test
    public void statement_newRelease_2일초과() {
        String statement = createRentalFor(TWO_DAYS, NEW_RELEASE);

        assertEquals("Rental Record for NAME_NOT_IMPORTANT\n" +
                "\t6.0(비디오)\n" +
                "Amount owed is 6.0\n" +
                "You earned 2 frequent renter pointers", statement);
    }

    @Test
    public void statement_childrens_3일초과() {
        String statement = createRentalFor(THREE_DAYS, CHILDRENS);

        assertEquals("Rental Record for NAME_NOT_IMPORTANT\n" +
                "\t1.5(비디오)\n" +
                "Amount owed is 1.5\n" +
                "You earned 1 frequent renter pointers", statement);
    }

    @Test
    public void statement_childrens_2일초과() {
        String statement = createRentalFor(TWO_DAYS, CHILDRENS);

        assertEquals("Rental Record for NAME_NOT_IMPORTANT\n" +
                "\t1.5(비디오)\n" +
                "Amount owed is 1.5\n" +
                "You earned 1 frequent renter pointers", statement);
    }

    private String createRentalFor(int daysRented, int priceCode) {
        Movie movie = new Movie(TITLE, priceCode);
        Rental rental = new Rental(movie, daysRented);
        customer.addRental(rental);

        return customer.statement();
    }
}

// After
public class CustomerTest {
    public static final int ONE_DAY = 1;
    public static final int TWO_DAYS = 2;
    public static final int THREE_DAYS = 3;
    public static final int FOUR_DAYS = 4;

    // 이름을 중요하지 않음
    String name= "NAME_NOT_IMPORTANT";
    Customer customer = new Customer(name);

    @Before
    public void setUp() {
        System.out.println("setUp Object: " + this);
    }

    @After
    public void tearDown() {
        System.out.println("tearDown Object: " + this);
    }

    @Test
    public void test_객체_생성() {
        String statement = customer.statement();

        assertEquals("Rental Record for NAME_NOT_IMPORTANT\n" +
                "Amount owed is 0.0\n" +
                "You earned 0 frequent renter pointers", statement);
    }

    @Test
    public void statement_regular_2일초과() {
        String statement = createRegularRentalFor(TWO_DAYS);

        assertEquals("Rental Record for NAME_NOT_IMPORTANT\n" +
                "\t2.0(비디오)\n" +
                "Amount owed is 2.0\n" +
                "You earned 1 frequent renter pointers", statement);
    }

    @Test
    public void statement_regular_3일초과() {
        String statement = createRegularRentalFor(THREE_DAYS);

        assertEquals("Rental Record for NAME_NOT_IMPORTANT\n" +
                "\t3.5(비디오)\n" +
                "Amount owed is 3.5\n" +
                "You earned 1 frequent renter pointers", statement);
    }

    @Test
    public void statement_newRelease_2일초과() {
        String statement = createNewReleaseRentalFor(TWO_DAYS);

        assertEquals("Rental Record for NAME_NOT_IMPORTANT\n" +
                "\t6.0(비디오)\n" +
                "Amount owed is 6.0\n" +
                "You earned 2 frequent renter pointers", statement);
    }

    @Test
    public void statement_newRelease_3일초과() {
        String statement = createNewReleaseRentalFor(THREE_DAYS);

        assertEquals("Rental Record for NAME_NOT_IMPORTANT\n" +
                "\t9.0(비디오)\n" +
                "Amount owed is 9.0\n" +
                "You earned 2 frequent renter pointers", statement);
    }

    @Test
    public void statement_childrens_2일미만() {
        String statement = createChildrensRentalFor(ONE_DAY);

        assertEquals("Rental Record for NAME_NOT_IMPORTANT\n" +
                "\t1.5(비디오)\n" +
                "Amount owed is 1.5\n" +
                "You earned 1 frequent renter pointers", statement);
    }

    @Test
    public void statement_childrens_2일초과() {
        String statement = createChildrensRentalFor(TWO_DAYS);

        assertEquals("Rental Record for NAME_NOT_IMPORTANT\n" +
                "\t1.5(비디오)\n" +
                "Amount owed is 1.5\n" +
                "You earned 1 frequent renter pointers", statement);
    }

    @Test
    public void statement_childrens_3일초과() {
        String statement = createChildrensRentalFor(THREE_DAYS);

        assertEquals("Rental Record for NAME_NOT_IMPORTANT\n" +
                "\t1.5(비디오)\n" +
                "Amount owed is 1.5\n" +
                "You earned 1 frequent renter pointers", statement);
    }

    @Test
    public void statement_childrens_4일초과() {
        String statement = createChildrensRentalFor(FOUR_DAYS);

        assertEquals("Rental Record for NAME_NOT_IMPORTANT\n" +
                "\t3.0(비디오)\n" +
                "Amount owed is 3.0\n" +
                "You earned 1 frequent renter pointers", statement);
    }

    @Test
    public void statementFor_() {
        customer.addRental(createRental(Movie.NEW_RELEASE, FOUR_DAYS));
        customer.addRental(createRental(Movie.NEW_RELEASE,THREE_DAYS));
        customer.addRental(createRental(Movie.REGULAR, FOUR_DAYS));
        customer.addRental(createRental(Movie.CHILDRENS, TWO_DAYS));

        assertEquals("Rental Record for NAME_NOT_IMPORTANT\n" +
                "\t12.0(비디오)\n" +
                "\t9.0(비디오)\n" +
                "\t5.0(비디오)\n" +
                "\t1.0(비디오)\n" +
                "Amount owed is 27.0\n" +
                "You earned 6 frequent renter pointers", customer.statement());
    }


    private String createRegularRentalFor(int daysRented) {
        int priceCode = Movie.REGULAR;
        return createRentalFor(priceCode, daysRented);
    }

    private String createNewReleaseRentalFor(int daysRented) {
        int priceCode = Movie.NEW_RELEASE;
        return createRentalFor(priceCode, daysRented);
    }

    private String createChildrensRentalFor(int daysRented) {
        int priceCode = Movie.CHILDRENS;
        return createRentalFor(priceCode, daysRented);
    }

    private String createRentalFor(int priceCode, int daysRented) {
        String title = "비디오";
        Movie movie = new Movie(title, priceCode);
        Rental rental = new Rental(movie, daysRented);
        customer.addRental(rental);
        return customer.statement();
    }

    private Rental createRental(int priceCode, int daysRented) {
        String title = "비디오";
        Movie movie = new Movie(title, priceCode);
        Rental rental = new Rental(movie, daysRented);
        return rental;
    }
}
----

===== High Cohesion, Low Coupling
* 응집도가 높아야 함
** 응집도는 왜 클래스에 있어야 하나 ?
** Customer f1, f2 메서드와 m1, m2 필드가 존재할 때 
** f1 - m1, f2 - m2 만 사용한다면 서로 다른 것이기 때문에 분리가 필요함
** f1 - m1, f2 - m2, f1 - m2, f2 - m1을 사용한다면 응집도가 높기 때문에 그 클래스가 하는 역할이 맞음
** 자기 것을 쓰는 것이 좋음
* 복잡도가 낮아야 함
** 복잡도 종류가 많음
** 입력 타입이나 반환 타입이 바뀌는 경우 툴이 자동적으로 해주지 않음
** 너도 알고 나도 알면 좋지만 싸이클 의존성이 생기면 좋지 않음:)
* 그렇게 가야 하는 근거가 중요함!

[source, java]
----
// before
// Rental
// * Rental에서 Movie로 옮길 때 Rental이 매개변수로 넘어감
double amountFor() {
    int thisAmount = 0;

    switch (getMovie().getPriceCode()) {
    case Movie.REGULAR:
        thisAmount += 2;
        if (getDaysRented() > 2)
            thisAmount += (getDaysRented() - 2) * 1.5;
        break;

    case Movie.NEW_RELEASE:
        thisAmount += getDaysRented() * 3;
        break;

    case Movie.CHILDRENS:
        thisAmount += 1.5;
        if (getDaysRented() > 3)
            thisAmount += (getDaysRented() - 3) * 1.5;
        break;
    }
    return thisAmount;
}

// after
// Movie
// * Rental 매개변수가 없어짐
double amountFor(int daysRented) {
    double thisAmount = 0;

    switch (getPriceCode()) {
        case REGULAR:
            thisAmount += 2;
            if (daysRented > 2)
                thisAmount += (daysRented - 2) * 1.5;
            break;

        case NEW_RELEASE:
            thisAmount += daysRented * 3;
            break;

        case CHILDRENS:
            thisAmount += 1.5;
            if (daysRented > 3)
                thisAmount += (daysRented - 3) * 1.5;
            break;
    }

    return thisAmount;
}

// Rental 
double amountFor() {
    int daysRented = getDaysRented();
    return movie.amountFor(daysRented);
}
----

* 단일 책임의 원칙

[source, java]
----
// before
// Rental
for(Rental rental : rentals) {
    double thisAmount = rental.amountFor();

    // add bonus for a two day new release rental
    if ((rental.getMovie().getPriceCode() == Movie.NEW_RELEASE) && rental.getDaysRented() > 1)
        frequentRenterPoints++;
    // show figures
    result += "\t" +  String.valueOf(thisAmount) + "(" + rental.getMovie().getTitle() + ")" + "\n";			// add frequent renter points

    frequentRenterPoints++;
    
    totalAmount += thisAmount;
}

// after
// Customer
for(Rental rental : rentals) {
    double thisAmount = rental.amountFor();
    frequentRenterPoints += rental.getFrequentRenterPoints();

    result += "\t" +  String.valueOf(thisAmount) + "(" + rental.getMovie().getTitle() + ")" + "\n";

    totalAmount += thisAmount;
}

// Rental
// #1.
// Rental 기준에서 movie 속성이나 메서드를 2개를 사용함. 자신의 것은 1개를 사용함. 그렇기 때문에 movie로 옮기는 것이 좋음
int getFrequentRenterPoints() {
    int frequentRenterPoints = 1;
    int daysRented = getDaysRented();
    
    if ((movie.getPriceCode() == Movie.NEW_RELEASE) && daysRented > 1)
        frequentRenterPoints++;

    return frequentRenterPoints;
}

// #2.
// 수정된 버전
public int getFrequentRenterPoints() {
    int daysRented = getDaysRented();
    return movie.getFrequenRenterPoints(daysRented);
}

// Movie
public int getFrequenRenterPoints(int daysRented) {
    int frequentRenterPoints = 1;

    if ((getPriceCode() == NEW_RELEASE) && daysRented > 1)
        frequentRenterPoints++;

    return frequentRenterPoints;
}
----

* 마틴 파울러 책에서 나오는 이야기임 -> for loop 3번 도는 것. 성능 이슈가 있지 않나 ?
** 성능 기준으로 포커싱을 맞추면 코드가 나빠짐
** 요즘 시대 멀티 코어
** 일반적으로 성능은 나중에 고려함. 역할을 나누는 것이 중요함

[source, java]
----
// before
// 성능 차이가 많이 나지 않음
// #1
for(Rental rental : rentals) {
    frequentRenterPoints += rental.getFrequentRenterPoints();

    result += "\t" +  String.valueOf(rental.amountFor()) + "(" + rental.getMovie().getTitle() + ")" + "\n";

    totalAmount += rental.amountFor();
}

// #2 
for(Rental rental : rentals) {
    frequentRenterPoints += rental.getFrequentRenterPoints();
}

for(Rental rental : rentals) {
    result += "\t" + String.valueOf(rental.amountFor()) + "(" + rental.getMovie().getTitle() + ")" + "\n";
}

for(Rental rental : rentals) {
    totalAmount += rental.amountFor();
}
----

[source, java]
----
public String statement() {
    String result = statementHeader() + showFigures() + statementTail();
    return result;
}

private String statementTail() {
    String result = "Amount owed is " + String.valueOf(getTotalAmount()) + "\n";
    result += "You earned " + String.valueOf(getFrequentRenterPoints()) + " frequent renter pointers";
    return result;
}

private String showFigures() {
    String result = "";

    for(Rental rental : rentals) {
        result += "\t" + String.valueOf(rental.amountFor()) + "(" + rental.getMovie().getTitle() + ")" + "\n";
    }

    return result;
}

private String statementHeader() {
    return "Rental Record for " + getName() + "\n";
}

private double getTotalAmount() {
    double totalAmount = 0;

    for(Rental rental : rentals) {
        totalAmount += rental.amountFor();
    }

    return totalAmount;
}

private int getFrequentRenterPoints() {
    int frequentRenterPoints = 0;

    for(Rental rental : rentals) {
        frequentRenterPoints += rental.getFrequentRenterPoints();
    }

    return frequentRenterPoints;
}
----

===== 오래 기억하고 싶은 것은 ? 반복적으로 끄집어내는 것이 좋음. 책을 여러 번 읽는 것보다 셀프 테스트를 하는 것이 더 좋음

===== Statement 대신 HTML를 어떻게 꺼내올 것인가?
* Customer에 있는 Statement 를 다 제거해야 함. Customer는 Statement를 알 수 없음
* List보다 iterable을 사용하는 것이 좋음

===== ATDD
* TDD, BDD, Step by Egen
* 요구사항 파악(인수조건) -> 인수테스트 케이스 만듬 -> 인수테스트 케이스 개수만큼 자동화함 -> 개발팀은 빨간불이 켜진 것을 초록색으로 만드는 것이 중요함. 하나의 케이스에 대해 TDD로 작성함 -> 자동화로 넘어와서 다른 클래스 작성함
* Outside-inside approch
* Inside-outside approch

=== 2018.04.13 수업내용

===== 디자인 패턴을 어떻게 공부할 것인가?
* 켄트 백의 구현 패턴
* [패턴을 활용한 리팩터링](http://www.yes24.com/24/goods/14752528)

===== 요구사항 분석을 체계적으로 하는 방법
* 시나리오
* 시뮬레이션
* Paper Prototyping

===== TDD
* TDD를 하면 지식의 양이 많아질 때 설계 단계를 가짐
* 아는 지식만큼 설계 과정을 가져야 함
* 첫 번째 테스트 케이스를 만들 때 인터페이스를 무엇으로 만들지 정의됨
* 빨간 불를 보는 것이 중요함
* 리팩토링 할 것이 있나요?
* 입력을 비슷하게 동작하는 얘들을 모아놓음 => 동등 클래스
** 1, 2를 통해 테스트 케이스 만들고 솔루션의 일반화를 할 수 있음
** 구체적인 예제를 통해 몇 가지 만들고 일반화한 다음에, 리팩토링 하고 테스트 케이스도 리팩토링이 필요함
* TDD로 개발하다가 더 이상 실패한 테스트 케이스를 만들 수 경우가 완료됨
** 내가 요구사항을 잘못 이해했거나
** 정말 요구사항을 잘 이해해서 만들다보면
** 수련할 때 하나하나씩 단계를 거쳐가면서 하는 것이 좋음
** FizzBuzz 구현할 때 1부터 100까지 출력이 필요하다면 출력에 대한 값을 테스트 하는 것이 아니라 1부터 100까지 루프가 제대로 도는지 확인이 필요한 것!

===== TDD 수련
* http://cyber-dojo.org/[CyberDojo]
* http://exercism.io/languages[Exercism]

===== 유닛테스트
* Arrange(Given) => 데이터 준비
* Act(When) => 제품 코드를 불러옴
* Assert(Then) => 결과가 맞는지 확인이 필요함
** Arrange가 같다는 것은 결과가 같다는 의미
** 불변은 생성자
** 가변은 Setter

===== TDD의 느낀 점
* 분할정복 같음
* Input과 Output 최소 단위로 쪼개고 일반화를 시키는 과정
* 단계적으로 짤게 쪼개는 생각하는 훈련이 필요함

===== 기타
* http://coded.kr

===== 테스트 재정의하기 
* 시스템이 요구사항 대로 동작하는지를 테스트하는 것은 테스팅인가?
** Specified => 일한 사람(개발자)
** Unspecified => QA, 매뉴얼 테스터
** 체킹 => 요구사항 대로 구현되었는지 검사하는 과정
** 테스팅 => Unspecified

===== 인수 테스트
* Face to Face Communication
* 구체적인 예로 커뮤니케이션 하고 요구사항을 이해해야 함

===== 유지보수 하기 좋은 코드
* 추상화가 잘 된 코드

===== OCP, 다형성
* 수정사항에 대해 고쳐지는 범위가 없는 곳이 제일 좋음
* 만약 그렇지 않다면 짧은 주기로 테스트 주기를 돌리면 됨