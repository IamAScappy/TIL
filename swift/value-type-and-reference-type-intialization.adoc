= 값 타입과 참조 타입의 초기화

=== Swift Programming Guide 발췌한 초기화 설명

===== Intialization
* 클래스, 열거형, 구조체 인스턴스를 사용하기 위한 준비 과정
* 해당 인스턴스의 각각 저장된 속성의 초기값을 설정하는 것과 그 외의 다른 설정 또는 새 인스턴스 사용하기 전에 필요한 초기화를 함
* 특정 타입의 새 인스턴스를 만들 때 호출될 수 있는 특수 메서드 
* Objective-C와 달리 Swift는 값을 반환하지 않음
* 주요한 역할은 새 인스턴스가 처음 사용되기 전에 잘못된 곳이 없이 초기화되었는지 보장하는 것

===== Initializer Delegation for Value Types

[source, swift]
----
// Initializer Delegation for Value Types
// 이니셜라이저는 인스턴스 초기화 수행 중 다른 이니셜라이저를 호출할 수 있음 => Initializer Delegation 
// 중복 코드를 피할 수 있음
// 클래스 타입이냐 값 타입에 따라 Initializer Delegation가 어떤 형태로 허용되는가, 어떻게 작동하는지 그 규칙이 다름
// 값 타입인 열거형이나 구조체는 상속을 지원하지 않음. 그렇기에 Initializer Delegation 과정이 비교적 간단함
// 클래스는 다른 클래스에서 상속받을 수 있음. 이는 곧 클래스는 상속받은 Stored Property가 초기화 과정 중에 올바르게 할당되었는지 보장해야 하는 추가적인 책임을 있다는 것을 뜻함
/*
    Value Type에서 기본 이니셜라이저와 멤버 단위 이니셜 라이저, 그리고 사용자 정의 이니셜라이저를 동시에 쓰길 원한다면 
    이니셜라이저를 원래 구현 부분에서 작성하기보다 Extension으로 작성하는 것이 좋음
*/ 
struct Size {
    var width = 0.0, height = 0.0
}

struct Point {
    var x = 0.0, y = 0.0
}

struct Rect {
    var origin = Point()
    var size = Size()

    init() {}

    init(origin: Point, size: Size) {
        self.origin = origin
        self.size = size
    }

    init(center: Point, size: Size) {
        let originX = center.x - (size.width / 2)
        let originY = center.y - (size.height / 2)
        self.init(origin: Point(x: originX, y: originY), size: size)
    }
}

let basicRect = Rect()
// basicRect's origin is (0.0, 0.0) and its size is (0.0, 0.0)

let originRect = Rect(origin: Point(x: 2.0, y: 2.0),
                      size: Size(width: 5.0, height: 5.0))
// originRect's origin is (2.0, 2.0) and its size is (5.0, 5.0)

let centerRect = Rect(center: Point(x: 4.0, y: 4.0),
                      size: Size(width: 3.0, height: 3.0))
// centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0)
----

===== Class Inheritance, Initialization: 지정 이니셜라이저와 편의 이니셜라이저
* 지정 이니셜라이저
** 클래스의 주 이니셜라이저 
** 해당 클래스에서 접하는 모든 속성을 완전히 초기화하고 적절한 부모 클래스 이니셜라이저를 호출하여 초기화 과정을 부모 클래스로 연쇄시킴
** 클래스들은 매우 작은 수의 지정 이니셜라이저를 가지는 경향이 있으며 일반적으로 클래스는 오직 하나만 가짐
* 편의 이니셜라이저
** 클래스를 지탱하는 두 번째 이니셜라이저임
** 편의 이니셜라이저를 정의하여 같은 클래스 내의 지정 이니셜라이저를 호출하는 편의 이니셜라이저를 만들 수 있음
** 편의 이니셜라이저를 통해 호출하는 지정 이니셜라이저의 몇몇 파라미터를 기본 값으로 설정할 수 있음
** 편의 이니셜라이저를 정의하여 특정 역할이나 입력 값 타입에 대한 클래스의 인스턴스를 만들 수 있음
** 클래스가 필요로 하지 않으면 편의 이니셜라이저를 제공할 필요 없음
** 편의 이니셜라이저는 보통 초기화 패턴을 단축하거나 클래스의 의도를 명확하게 할 때 만듬

[source, swift]
----
// 지정 이니셜라이저
init(parameters) {
    statements
}


// 편의 이니셜라이저
convenience init(parameters) {
    statements
}
----

===== Initializer Delegation for Class Types
* 3개의 규칙을 이니셜라이저 간의 Delegation에 적용함
** Rule 1. 지정 이니셜라이저는 반드시 바로 위 부모 클래스의 지정 이니셜라이저를 호출함
** Rule 2. 편의 이니셜라이저는 반드시 같은 클래스 내의 호출 가능한 다른 이니셜라이저를 호출함
** Rule 3. 편의 이니셜라이저는 반드시 지정 이니셜라이저를 호출하는 것으로 끝내야 함
* 간단히 기억하는 방법은 
** 지정 이니셜라이저는 반드시 위로 Delegate
** 편의 이니셜라이저는 반드시 클래스 내부를 가로질러 Delegate 

image:./images/initializer-delegation-1.png[]

* 부모 클래스는 지정 이니셜라이저 1개와 편의 이니셜라이저를 2개 가지고 있음
* 부모 클래스는 더는 부모 클래스가 없어서 규칙 1을 적용하지 않음
* 그림의 하위 클래스는 2개 지정 이니셜라이저와 1개 편의 이니셜라이저를 가지고 있음
* 규칙 2, 3을 만족하며 규칙 1을 만족하기 위해서 두 개의 지정 이니셜라이저는 반드시 부모 클래스에 하나 지정 이니셜라이저를 호출해야 함
* 이 규칙들은 각각 클래스 생성하는 방법에 영향을 주지 않음. 클래스 구현의 작성에만 영향을 줌

image:./images/initializer-delegation-2.png[]

===== Two-Phase Initialization(2단계 초기화)
* Swift 초기화는 두 단계 과정을 거침
** 첫 번째 단계는 해당 클래스가 가지는 각각 Stored Property에 초기값을 할당함. Stored Property 초기 상태가 정해지면 두 번째 단계가 시작함
** 두 번째 단계에서 클래스 인스턴스가 사용될 준비가 되기 전까지 각각 클래스가 Stored Property를 사용자 정의할 기회를 가짐
** 2단계 초기화 과정을 사용하는 것은 초기화를 안전하게 하면서도 클래스 상속 계층 상에서 각각 클래스는 완전한 유연성을 가짐
** 2단계 초기화는 속성 값이 초기화 되기 전에 접근되는 것을 방지하며 다른 이니셜라이저에 의해 의도치 않게 다른 값이 설정하는 것을 방지함

> Objective-C의 초기화 비슷함. Swift와 차이점은 첫 번째 단계에 있음. Objective-C는 0이나 Null를 모든 속성에 할당함. Swift는 초기화 흐름을 좀 더 유연하게 사용자 정의 초기값을 설정할 수 있게 해줌. 그리고 0 이나 nil이 기본값으로 유효하지 않은 타입에 대처할 수 있게 해줌

* 스위프트 컴파일러는 2단계 초기화가 에러 없이 완료할 수 있도록 4가지 Safety Check를 함
** Safety Check 1 
*** 지정 이니셜라이저는 해당 클래스에서 도입한 모든 속성을 초기화되었는지 부모 클래스의 이니셜라이저를 대리하기 전에 확실히 해야 함
*** 객체를 위한 메모리는 저장 프로퍼티의 초기 상태가 알려져야 완전히 초기화되었다고 간주함
*** 이 규칙을 만족하기 위해서 지정 이니셜라이저 초기화 연쇄를 위로 전달하기 전에 자신의 프로퍼티가 초기화되었음을 확실히 해야 함
** Safety Check 2
*** 지정 이니셜라이저는 상속받은 프로퍼티에 값을 할당하기 전에 상위 클래스의 이니셜라이저를 대리 수행해야 함. 만약 그렇게 하지 않으면 지정 이니셜라이저가 할당한 새 값은 상위 클래스의 초기화 과정 중에 덮어 씌워짐
** Safety Check 3
*** 편의 이니셜라이저는 같은 클래스 내부에서 정의된 프로퍼티를 포함한, 어떤 프로퍼티에라도 값을 할당하기 전에 다른 이니셜라이저를 대리 수행해야 함. 그렇게 하지 않으면 편의 이니셜라이저가 할당한 새 값은 해당 클래스의 지정 이니셜라이저에 의해 덮어씌워 짐
** Safety Check 4
*** 이니셜라이저는 어떠한 인스턴스 메서드로 호출할 수 없음. 어떠한 인스턴스 속성도 읽을 수 없음. self를 초기화 첫 단계가 끝나기 전에 참조할 수 없음

* 위의 4가지 Safety Check에 의해 2단계 초기화가 진행되는지 설명함
** Phase 1
*** 클래스의 지정 이니셜라이저나 편의 이니셜라이저가 호출됨
*** 클래스 인스턴스를 위해 메모리가 할당됨. 메모리는 아직 초기화되지 않음
*** 클래스의 지정 이니셜라이저는 해당 클래스에 의해 도입된 모든 저장 프로퍼티가 값을 가졌음을 확인함. 이때서야 해당 저장 프로퍼티를 위한 메모리가 초기화됨
*** 지정 이니셜라이저는 상위 클래스 이니셜라이저가 같은 작업을 하도록 해당 클래스로 순서를 넘김
*** 이 작업의 연쇄는 클래스 상속 계층의 꼭대기로 올라갈 때까지 계속됨
*** 연쇄의 꼭대기에 도착하면 연쇄 마지막 클래스는 모든 저장 프로퍼티의 값을 가진 것을 확인함. 인스턴스 메모리는 완전히 초기화되었다고 간주하고 첫 번째 단계가 끝남
** Phase 2
*** 연쇄 꼭대기에서 아래로 내려오면서 작업하여 연쇄 안에 있는 지정 이니셜라이저들은 추가로 인스턴스가 사용자 정의할 수 있는 선택권이 있음. 이때, 이니셜라이저는 self에 접근할 수 있고 자신의 프로퍼티를 변경하거나 인스턴스 메서드를 호출할 수 있음
*** 마지막으로 연쇄 안에 있는 편의 이니셜라이저들이 인스턴스를 사용자 정의할 수 있는 선택권이 있으며 self를 이용하여 작업할 수 있음

* 첫 번째 예제
** 첫 번째 그림에서 초기화는 하위 클래스의 편의 이니셜라이저를 호출하는 것으로 시작함. 이 편의 이니셜라이저는 어떤 속성도 변경할 수 없으며 편의 이니셜라이저는 같은 클래스 안 지정 이니셜라이저를 대리 실행함
** 지정 이니셜라이저는 Safety Check 1에 의해, 모든 서브 클래스의 속성이 값을 가졌는지 검사함
** 그 후, 하위 지정 이니셜라이저는 상위 클래스의 지정 이니셜라이저를 불러 초기화 연쇄로 위로 올라감
** 상위 클래스 속성이 모두 값을 가졌는지 검사함. 그리고 초기화할 상위 클래스가 없기 때문에 더 이상 Delegation은 필요하지 않음. 상위 클래스의 속성들이 초기값을 가지는 순간 인스턴스의 메모리가 완전히 초기화되었다고 간주하고 1단계가 끝남

* 두 번째 예제
** 상위 클래스의 지정 이니셜라이저는 인스턴스를 추가적으로 사용자 정의할 수 있는 기회가 있지만 해도 그만, 안해도 그만!
** 상위 클래스의 지정 이니셜라이저가 종료하면 하위 클래스의 이니셜라이저가 추가 사용자 정의를 수행할 수 있음. 이때도 해도 그만, 안해도 그만!
** 서브 클래스 지정 이니셜라이저가 종료하면 처음 지정 이니셜라이저를 호출한 편의 이니셜라이저가 추가적으로 사용자 정의를 수행함

image:./images/two-phase-initialization-1.png[]

image:./images/two-phase-initialization-2.png[]

=== 개인적인 설명 추가 

===== 생성자 상속과 재정의
* C 언어 시절, 객체 인스턴스를 생성하면 쓰레기 값이 들어있었음
* OOP 시절로 넘어오면서 초기값이 없으면 생성자에게 값을 셋팅해줌
* 초기값 중에서 Primitive Type이 아닌 경우 객체 안의 객체를 만들었을 때(= 소유권을 가진 형태), 이럴 때 소멸자가 해제하자!
* Java, C++, Objective-C(deallow) => 생성자, 소멸자는 쌍으로 만들어야 했음

===== 2단계 초기화
* SubClass의 프로러티 값을 초기화하고 
* SuperClass 생성자를 호출하고 SuperClass의 프로퍼티 값을 초기화함
* 그리고 self가 완전함

===== 상속 초기화
* 상속받은 SubClass에서 보통 생성자에서 super를 먼저 호출하는 경우가 많지만 내가 만든 SuperClass, SubClass도 존재함. SuperClass의 메서드에 로직이 몰려 있는 경우 SubClass에서 super를 나중에 호출해야 함
* Stack 구조보다 다형성으로 인한 문제때문에 호출 구조가 뒤로 가야하는 경우가 있음

=== 참고
* https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/[Swift Language Guide]
* http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791162240052&orderClick=LAH&Kc=[스위프트 프로그래밍:Swift4]