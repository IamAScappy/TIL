= 초기화(Intialization)

=== 초기화
* 클래스, 열거형, 구조체 인스턴스를 사용하기 위한 준비 과정
* 해당 인스턴스의 각각 저장된 속성의 초기값을 설정하는 것과 그 외의 다른 설정 또는 새 인스턴스 사용하기 전에 필요한 초기화를 함
* 특정 타입의 새 인스턴스트를 만들 때 호출될 수 있는 특수 메서드 
* Objective-C와 달리 Swift는 값을 반환하지 않음
* 주요한 역할은 새 인스턴스가 처음 사용되기 전에 잘못된 곳이 없이 초기화 되었는지 보장하는 것

=== Stored Property에 초기값 설정하기 

[source, swift]
----
// Stored Property 초기값 설정하기
// 기본 값을 지정하거나 초기화에서 초기값을 설정할 때 어떠한 속성 감시자도 호출하지 않고 값이 직접 설정됨

init() {
    // perform some initialization here
}

struct Fahrenheit {
    var temperature: Double
    init() {
        temperature = 32.0
    }
}
var f = Fahrenheit()
print("The default temperature is \(f.temperature)° Fahrenheit")
// Prints "The default temperature is 32.0° Fahrenheit"


// 기본 속성 값
// 만약 속성이 언제나 똑같은 초기값을 가진다면 초기화 안에서 값을 설정하기보다 기본 값을 주는 것이 나음. 
// 결과적으로 같지만 기본값이 속성 선언에 더 근접해서 속성의 초기화함. 결과적으로 더 짧고 명확한 이니셜라이저를 작성할 수 있게 함. 기본 값에서 속성의 타입을 개발자가 유추할 수 있게 함
struct Fahrenheit {
    var temperature = 32.0
}
----

=== Customizing Initialization

[source, swift]
----
// 옵셔널 속성 타입을 이용하거나 상수 속성을 초기화 과정 중에 변경하는 것으로 초기화 과정을 사용자가 정의하는 것
// 초기화 파라미터
struct Celsius {
    var temperatureInCelsius: Double

    init(fromFahrenheit fahrenheit: Double) {
        temperatureInCelsius = (fahrenheit - 32.0) / 1.8
    }

    init(fromKelvin kelvin: Double) {
        temperatureInCelsius = kelvin - 273.15
    }
}

let boilingPointOfWater = Celsius(fromFahrenheit: 212.0)
// boilingPointOfWater.temperatureInCelsius is 100.0
let freezingPointOfWater = Celsius(fromKelvin: 273.15)
// freezingPointOfWater.temperatureInCelsius is 0.


// Parameter Names and Argument Labels
struct Color {
    let red, green, blue: Double

    init(red: Double, green: Double, blue: Double) {
        self.red   = red
        self.green = green
        self.blue  = blue
    }
    
    init(white: Double) {
        red   = white
        green = white
        blue  = white
    }
}

let magenta = Color(red: 1.0, green: 0.0, blue: 1.0)
let halfGray = Color(white: 0.5)

let veryGreen = Color(0.0, 1.0, 0.0)
// this reports a compile-time error - argument labels are required
// 오류 발생


// Initializer Parameters Without Argument Labels
struct Celsius {
    var temperatureInCelsius: Double
    init(fromFahrenheit fahrenheit: Double) {
        temperatureInCelsius = (fahrenheit - 32.0) / 1.8
    }
    init(fromKelvin kelvin: Double) {
        temperatureInCelsius = kelvin - 273.15
    }
    init(_ celsius: Double) {
        temperatureInCelsius = celsius
    }
}
let bodyTemperature = Celsius(37.0)
// bodyTemperature.temperatureInCelsius is 37.0


// Optional Property Types
// nil로 초기화함
class SurveyQuestion {
    var text: String
    var response: String?

    init(text: String) {
        self.text = text
    }

    func ask() {
        print(text)
    }
}

let cheeseQuestion = SurveyQuestion(text: "Do you like cheese?")
cheeseQuestion.ask()
// Prints "Do you like cheese?"
cheeseQuestion.response = "Yes, I do like cheese."


// Assigning Constant Properties During Initialization
// 초기화가 끝나기 직전까지 상수 속성의 값을 초기화 과정 중 바꿀 수 있음

/*
    클래스 인스턴스는 상수 속성의 값을 오직 초기화 과정 중에 해당 클래스에 의해서만 바꿀 수 있음.
    상수 속성은 Subclass에 의해 변경될 수 없음
*/
class SurveyQuestion {
    let text: String
    var response: String?

    init(text: String) {
        self.text = text
    }

    func ask() {
        print(text)
    }
}

let beetsQuestion = SurveyQuestion(text: "How about beets?")
beetsQuestion.ask()
// Prints "How about beets?"
beetsQuestion.response = "I also like beets. (But not with cheese.)"
----

=== Default Initializers

[source, swift]
----
// 이니셜라이저를 가지지 않는 구조체나 Base Class에 대해 기본 이니셜라이저를 제공함
class ShoppingListItem {
    var name: String?
    var quantity = 1
    var purchased = false
}

var item = ShoppingListItem()


// Memberwise Initializers for Structure Types
// 위의 기본 이니셜라이저 외에도 구조체 타입은 자동적으로 멤버 단위 이니셜라이저를 부여받음
struct Size {
    var width = 0.0, height = 0.0
}

let twoByTwo = Size(width: 2.0, height: 2.0)
----

=== Initializer Delegation for Value Types

[source, swift]
----
// 이니셜라이저는 인스턴스 초기화 수행 중 다른 이니셜라이저를 호출 할 수 있음 => Initializer Delegation 
// 중복 코드를 피할 수 있음
// 클래스 타입이냐 값 타입에 따라 Initializer Delegation가 어떤 형태로 어향되는가, 어떻게 작됭하는지 그 규칙이 다름
// 값 타입인 열거형이나 구조체는 상속을 지원하지 않음. 그렇기에 Initializer Delegation 과정이 비교적 간단함
// 클래스는 다른 클래스에서 상속받을 수 있음. 이는 곧 클래스는 상속받은 Stored Property이 초기화 과정 중에 올바르게 할당되었는지 보장해야 하는 추가적인 책임을 있다는 것을 뜻함
/*
    Value Type에서 기본 이니셜라이저와 멤버 단위 이니셜 라이저, 그리고 사용자 정의 이니셜라이저를 동시에 쓰길 원한다면 
    이니셜라이저를 원래 구현부분에서 작성하기보다 Extension으로 작성하는 것이 좋음
*/
struct Size {
    var width = 0.0, height = 0.0
}

struct Point {
    var x = 0.0, y = 0.0
}

struct Rect {
    var origin = Point()
    var size = Size()

    init() {}

    init(origin: Point, size: Size) {
        self.origin = origin
        self.size = size
    }

    init(center: Point, size: Size) {
        let originX = center.x - (size.width / 2)
        let originY = center.y - (size.height / 2)
        self.init(origin: Point(x: originX, y: originY), size: size)
    }
}

let basicRect = Rect()
// basicRect's origin is (0.0, 0.0) and its size is (0.0, 0.0)

let originRect = Rect(origin: Point(x: 2.0, y: 2.0),
                      size: Size(width: 5.0, height: 5.0))
// originRect's origin is (2.0, 2.0) and its size is (5.0, 5.0)

let centerRect = Rect(center: Point(x: 4.0, y: 4.0),
                      size: Size(width: 3.0, height: 3.0))
// centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0)
----

=== Class Inheritance and Initialization

===== 지정 이니셜라이저와 편의 이니셜라이저
* 지정 이니셜라이저
** 클래스의 주 이니셜라이저 
** 해당 클래스에서 접하는 모든 속성을 완전히 초기화하고 적절한 부모 클래스 이니셜라이저를 호출하여 초기화 과정을 부모 클래스로 연쇄시킴
** 클래스들은 매우 작은 수의 지정 이니셜라이저를 가지는 경향이 있으며 일반적으로 클래스는 오직 하나만 가짐
* 편의 이니셜라이저
** 클래스를 지탱하는 두 번째 이니셜라이저임
** 편의 이니셜라이저를 정의하여 같은 클래스 내의 지정 이니셜라이저를 호출하는 편의 이니셜라이저를 만들 수 있음
** 편의 이니셜라이저를 통해 호출하는 지정 이니셜라이저의 몇몇 파라미터를 기본 값으로 설정할 수 있음
** 편의 이니셜 라이저를 정의하여 특정 역할이나 입력 값 타입에 대한 클래스의 인스턴스를 만들 수 있음
** 클래스가 필요로 하지 않드면 편의 이니셜라이저를 제공할 필요 없음
** 편의 이니셜라이저는 보통 초기화 패턴을 단축하거나 클래스의 의도를 명확하게 할 때 만듬

[source, swift]
----
// 지정 이니셜라이저
init(parameters) {
    statements
}


// 편의 이니셜라이저
convenience init(parameters) {
    statements
}
----

===== Initializer Delegation for Class Types
* 3개의 규칙을 이니셜라이저 간의 Delegation에 적용함
** Rule 1. 지정 이니셜라이저는 반드시 바로 위 부모 클래스의 지정 이니셜라이저를 호출함
** Rule 2. 편의 이니셜라이저는 반드시 같은 클래스 내의 호출 가능한 다른 이니셜라이저를 호출함
** Rule 3. 편의 이니셜라이저는 반드시 지정 이니셜라이저를 호출하는 것으로 끝내야 함
* 간단히 기억하는 방법은 
** 지정 이니셜라이저는 반드시 위를 대리함
** 편의 이니셜라이저는 반드시 클래스 내부를 가로질러서 대리함

image:./image/initializer-delegation-1.png[]

* 부모 클래스는 지정 이니셜라이저 1개와 편의 이니셜라이저를 2개 가지고 있음
* 부모 클래스는 더 이상 부모 클래스가 없기 때문에 규칙 1을 적용하지 않음
* 그림의 하위 클래스는 2개 지정 이니셜라이저와 1개 편의 이니셜라이저를 가지고 있음
* 규칙 2, 3를 만족하며 규칙 1을 만족하기 위해서 두 개의 지정 이니셜라이저는 반드시 부모 클래스에 하나 지정 이니셜 라이저를 호출해야 함
* 이 규칙들은 각각 클래스 생성하는 방법에 영향을 주지 않음. 클래스 구현의 작성에만 영향을 줌

image:./image/initializer-delegation-2.png[]

===== Two-Phase Initialization(2단계 초기화)
* Swift 초기화는 두 단계 과정을 거침
** 첫 번째 단계는 해당 클래스가 가지는 각각 Stored Property에 초기값을 할당함. Stored Property 초기 상태가 정해지면 두 번째 단계가 시작함
** 두 번째 단계에서 클래스 인스턴스가 사용될 준비가 되기 전까지 각각 클래스가 Stored Property을 사용자 정의할 기회를 가짐
** 2단계 초기화 과정을 사용하는 것은 초기화를 안전하게 하면서도 클래스 상속 계층 상에서 각각 클래스는 완전한 유연성을 가짐
** 2단계 초기화는 속성 값이 초기화 되기 전에 접근되는 것을 방지하며 다른 이니셜라이저에 의해 의도치 않게 다른 값이 설정하는 것을 방지함

> Objective-C의 초기화 비슷함. Swift와 차이점은 첫 번째 단계에 있음. Objective-C는 0이나 Null를 모든 속성에 할당함. Swift는 초기화 흐름을 좀 더 유연하게 사용자 정의 초기값을 설정할 수 있게 해줌. 그리고 0 이나 nil이 기본값으로 유효하지 않은 타입에 대처할 수 있게 해줌

* 스위프트 컴파일러는 2단계 초기화가 에러없이 완료할 수 있도록 4가지 안전 점검을 함
** Safety Check 1 
*** 지정 이니셜라이저는 해당 클래스에서 도입한 모든 속성을 초기화 되었는지 부모 클래스의 이니셜라이저를 대리하기 전에 확실히 해야함
*** 객체를 위한 메모리는 저장 프로퍼티의 초기 상태가 알려져야 완전히 초기화 되었다고 간주함
*** 이 규칙을 만족하기 위해서 지정 이니셜라이저 초기화 연쇄를 위로 전달하기 전에 자신의 프로퍼티가 초기화 되었음을 확실히 해야함
** Safety Check 2
*** 지정 이니셜라이저는 상속받은 프로퍼티에 값을 할당하기 전에 상위 클래스의 이니셜라이저를 대리 수행해야 함. 만약 그렇게 하지 않으면 지정 이니셜라이저가 할당한 새 값은 부모 클래스의 초기화 과정 중에 덮어 씌워짐
** Safety Check 3
*** 편의 이니셜라이저는 같은 클래스 내부에서 정의된 프로퍼티를 포함한, 어떤 프로퍼티에라도 값을 할당하기 전에 다른 이니셜라이저를 대리 수행해야 함. 그렇게 하지 않으면 편의 이니셜라이저가 할당한 새 값은 해당 클래스의 지정 이니셜라이저에 의해 덮어씌워질 것임
** Safety Check 4
*** 이니셜라이저는 어떠한 인스턴스 메서드로 호출할 수 없음. 어떠한 인스턴스 속성도 읽을 수 없음. self 를 초기화 첫 단계가 끝나기 전에 참조할 수 없음

[source, swift]
----

----

=== 참고
* https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/[Swift Language Guide]
* http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791162240052&orderClick=LAH&Kc=[스위프트 프로그래밍:Swift4]