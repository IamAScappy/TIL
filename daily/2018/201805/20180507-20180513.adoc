= 2018.05.07 - 2018.05.13

=== 2018.05.07

===== 할 일 
* [*] CardGameApp 2단계 진행하기
* [*] Beginning Auto Layout 강의 듣고 정리하기
* [*] 영어 공부
* [*] Getting Started with RxSwift
** [*] Introduction
** [*] Hello RxSwift
** [*] Installing RxSwift

===== 느낀 점
* 1일 1커밋. 1일 1풀리퀘 원칙을 지키자
* 영어 공부는 가깝게 접할 수 있는 분야에서부터 시작하자!

=== 2018.05.08

===== 할 일
* [*] CardGameApp 2단계 진행하기
* [*] 영어 공부
* [*] Beginning RxSwift
** [*] Creating Observables

===== 느낀 점
* 어제 어버이 날이라 아빠, 엄마에게 전화함. 부모님에게 선물을 드리는 대신 겨울에 가족 여행 가기로 함. 여행 준비 고고!

=== 2018.05.09

===== 할 일 
* [*] CardGameApp 2단계 진행하기
* [*] 영어 공부
* [*] Beginning RxSwift
** [*] Subscribing to Observables: Part 1
** [*] Subscribing to Observables: Part 2

=== 2018.05.10

===== 할 일
* [*] CardGameApp 3단계 진행하기
* [*] 영어 공부
* [*] MVVM 정리하기

===== 느낀 점
* ttps://www.slideshare.net/myeonginwoo/pptx-75959689[토이 프로젝트를 하자.PPTX]
* 설계 시, 고려해야 할 점
** 설계 과정에서 구조적인 문제도 있지만, 코드 구현도 어떻게 할 것인지 생각해봐야 함
** 코드 구현에서 직접 작성할 것인지, 오픈 소스를 쓸 것인지 생각해봐야 함
** 안전하게 체크하는 것도 중요하지만, 만약 예외 케이스에 걸리더라도 에러가 발생하더라도 시스템이 다운되지 않아야 함
** 입력받는 것에 대해서 데이터 저장, 모델링 어떻게 할 것인지 고민해봐야 함
** 코드에 너무 의존하려고 하면 안 됨. 예외사항도 생각해봐야 함
** 변수명 작성할 때 한글식으로 작성하지 말 것. 예를 들어 주민번호를 Jumin로 나타내지 말 것!

=== 2018.05.11

===== 할 일
* [*] CardGameApp 3단계 진행하기
* [*] 영어 공부

=== 2018.05.12

===== 할 일
* 휴식

=== 2018.05.13

===== 할 일 
* [*] CardGameApp 3단계 진행하기

===== 느낀 점
* 주로 많이 사용하는 라이브러리
** Alamofire + GPUImage + Realm + SnapKit + RxSwift + ReactorKit
* OOP 관련 글
** 일단 SRP는 단일 책임 원칙으로서, 클래스가 하나의 책임만을 가져야 된다는 뜻입니다. 여기서 책임이란 말의 정의를 먼저 이해하는 것이 중요합니다. 예를 들어, 클래스가 메소드 2개를 갖는다고 해서 2개의 책임을 가지는 것은 아닐 겁니다. 단일 책임 원칙을 지키고 있는 클래스라면, 그 2개의 메소드는 그보다 high level에서 “무언가(what)“를 하기 위해 존재하는 것일 겁니다. 즉, 여기서 그 하나의 일이라는 것이 하나의 책임이 됩니다. 어떤 클래스의 책임이라는 것은 그 클래스의 객체를 사용하는 클라이언트에 의해 정의됩니다. 다시 말하면, 클라이언트가 어떤 하나의 일을 하기 위해 그 클래스의 객체를 사용하게 되는 것이죠. 그러면 왜 클래스가 단 하나의 책임만 가져야 하는 것일까요? 책임은 변경의 이유라고도 합니다. 어떤 클래스를 변경해야 하는 이유가 두가지 이상 존재하면 그 클래스에는 두가지 이상의 책임이 존재한다고 봅니다. 클래스를 변경해야 하는 이유를 생각해보세요. 어떤 클래스를 변경해야 하는 상황이 왜 나타날까요? 그 클래스의 객체의 클라이언트 입장에서 현재 상황의 그 클래스는 클라이언트의 요구에 부합하지 못하기 때문에 그 클래스를 변경해야 하는 것입니다. OOP의 진정한 핵심은 현실 세계를 모델링하거나 하는 것보다, 소스 코드상에 존재하는 클래스 간의 의존 관계를 관리하는 것임을 생각해본다면, 클래스들은 자신을 변경해야 하는 이유가 하나여야 합니다. 엉클밥은 clean architecture라는 책에서 OOP에 대해 다음과 같이 말했습니다.
What is OO? There are many opinions and many answers to this question. To the software architect, however, the answer is clear: OO is the ability, through the use of polymorphism, to gain absolute control over every source code dependency in the system. It allows the architect to create a plugin architecture, in which modules that contain high-level policies are independent of modules that contain low-level details. The low-level details are relegated to plugin modules that can be deployed and developed independently from the modules that contain high-level policies. ISP는 인터페이스 분리 원칙으로서, 어떤 인터페이스는 그 **클라이언트** (가 요구하는 바)를 기준으로 분리되어야 한다는 뜻입니다. 어떤 클래스가 인터페이스 여러개를 구현하면 여러개의 책임을 갖는 것 아니냐고 하셨는데, 그렇게 여러  인터페이스를 구현한 클래스를 변경해야 하는 상황에 그 클래스를 변경한다고 해서 그 클라이언트들에도 영향이 생기는게 아니라고 생각합니다. ISP가 말하고자 하는 것은 어떤 클래스는 각 클라이언트에 대해서 정말 필요한 인터페이스만 노출해주라고 말하는 것이라고 생각합니다. 즉, 클라이언트가 어떤 객체를 인터페이스를 통해 바라볼 때 정말 자신이 필요한 인터페이스만 바라보면 되는 것입니다.  ISP가 적용되지 않은 상황은 어떤 클래스의 클라이언트가 필요하지는 않은 인터페이스에 의존하게 될 때입니다. 어떤 클래스가 2개 이상의 인터페이스를 구현해야 한다면 그렇게 하면 됩니다. 하지만 그 클래스의 객체를 사용할 클라이언트는 정말 자신이 필요한 인터페이스를 바탕으로 그 객체를 바라보면 됩니다. 각 클라이언트는 자기가 필요한 인터페이스만 보기 때문에 자신이 필요하지 않은 인터페이스에는 의존하지 않기 때문에 보호 받습니다. 다시 말하면, ISP 이야기를 떠나서 생각해보면, 클라이언트가 어떤 클래스를 인터페이스를 통해 바라보면 이미 indirection이 있는 것입니다(즉, 클라이언트는 인터페이스에만 의존합니다). 애플리케이션 런타임에 클라이언트는 결국 그 클래스의 객체를 사용하게 되겠지만, 위에서 말씀드렸듯이 OOP에서 핵심은 정적인 소스코드 상에서의 의존관계를 줄이는 것입니다. 이미 인터페이스를 통해 클라이언트와 그 클라이언트가 사용하는 클래스의 의존관계를 decoupled하게 만들었기 때문에 일단 안심입니다. 그런데 ISP는 여기서, 클라이언트는 어떤 클래스를 바라볼 때 정말 필요한 것만 바라보도록 하자고 말합니다. ISP도 결국에는 dependency management입니다. 자기가 필요한 인터페이스에만 의존하자는 것이고, 자기가 필요없는 것에는 의존하지 말자는 것입니다. 클린소프트웨어라는 책에는 다음과 같은 설명이 있습니다.(조금 수정)
비대한 클래스는 클라이언트들 간에 기이하고 해로운 결합을 유발한다. 한 클라이언트가 이 비대한 클래스에 변경을 가하면, 이 비대한 클래스를 사용하는 모든 클라이언트가 영향을 받게 된다. 그러므로 클라이언트는 자신이 실제로 호출하는 메서드에만 의존해야 한다. 그러려면, 이 비대한 클래스의 인터페이스를 각 클라이언트에 특정한(client-specific) 인터페이스 여러 개로 분리해야 한다(각 인터페이스는 그 비대한 인터페이스를 변경의 이유가 같은것끼리 책임으로 나누어지며 role을 형성). 각 클라이언트에 specific한 인터페이스는 자신의 specific한 클라이언트나 클라이언트 그룹이 호출하는 함수만 선언한다. 그러면 비대한 클래스가 모든 클라이언트에  specific한 인터페이스를 상속하고 구현할 것이다. 이렇게 하면 호출하지 않는 메서드에 대한 클라이언트의 의존성을 끊고, 클라이언트들은 서로에 대해 독립적이 될 수 있다.
막 썼는데 설명이 잘 되었는지 모르겠네요; 제가 주로 참고한 자료는 클린소프트웨어, 토비의스프링, 유튜브(https://www.youtube.com/user/codetemplate/videos)입니다… 여기 잘 설명되어 있어요... 더 정확한 내용은 저기서 보시는 게 나을 것 같아요. 추가적으로… https://cdn.tutsplus.com/net/uploads/2014/01/segregatedInterfaces.png 그림을 보시면, 그림과 다르게 HighWay와 ParkingLot을 하나의 클래스로 만들었다고 하더라도 애플리케이션의 주요 흐름은 왼편에 있습니다. 클라이언트들은 가운데에있는 인터페이스를 통해, 그 인터페이스를 구현한 클래스들로부터 보호받습니다. 각 클라이언트들은 정말 자기 자신이 필요한 인터페이스에만 의존합니다.. https://code.tutsplus.com/tutorials/solid-part-3-liskov-substitution-interface-segregation-principles--net-36710 / https://imgur.com/a/4aB6QUl / https://imgur.com/a/jOICCCq