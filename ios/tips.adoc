= Tips

===== Runtime Header
* `UIViewController.h, UIStoryboard.h, UIController.h 등` 구글에서 검색함
* Objective-C는 런타임 언어이기 때문에 private으로 선언하더라도 실제로 private으로 동작하지 않음
* Swift에서 꼼수로 사용 가능. 왜냐하면, Key-Value 형태이기 때문임

[source, swift]
----
func testJoinButton_push() {
    // given
    let storybaord = UIStoryboard(name: "Main", bundle: nil)
    let navigationController = storybaord.instantiateInitialViewController() as! UINavigationController
    let viewController = navigationController.topViewController as! LoginViewController
    UIApplication.shared.keyWindow?.rootViewController = navigationController
    _ = viewController.view
    
    let templates = viewController.value(forKey: "storyboardSegueTemplates") as? [AnyObject]
    let template = templates?.first as AnyObject
    
    let targetActions = viewController.joinButton.value(forKey: "_targetActions") as? [AnyObject]
    let buttonTarget = targetActions?.first?.value(forKey: "_target") as AnyObject
    
    XCTAssert(template === buttonTarget)

    // ...
}
----

===== Auto Layout Tips
* Content Hugging, Compression Resistance 안 쓴다는 생각을 버려라!
* translatesAutoresizingMaskIntoConstraints 아니면 Auto Layout
* Visual Format Language 사용함
* 제약을 적용 하기 위해서 두 객체의 x, y 좌표를 알아야 함
* 노락색 Indicator가 보인다면 Update Frames 메뉴를 선택함
* Copyright 같은 문구는 UILabel의 _AutoShrink_ 과 Add New Constraints의 _Constraint to margin 체크 박스, Bottom Margin의 Use Standard Value_ 를 이용하여 어느 기기에도 대응할 수 있음
* 고정된 너비와 높이 값은 피해야 함
* Subview들의 제약 조건을 개발자가 직접 관리하는 것보다 StackView를 이용할 수 있다면 이용하는 것이 좋음
* Multiplier의 비율은 정수로 계산하는 것이 좋음
* Priority가 1000은 필수 제약 조건, 1000보다 작으면 점선으로 표시되며 선택적 제약 조건

image:./images/auto-layout-14.png[45%, 45%]

[source, swift]
----
/* 
    * 'NSInternalInconsistencyException', reason: 'Mutating a priority from required to not on an installed constraint (or vice-versa) is not supported.  You passed priority 1000 and the existing priority was 800.'
*/

// 아래 코드로 UI Crash가 발생함
@IBAction func togglePriority(_ sender: Any) {
    width1.priority = width1.priority.rawValue < 1000 ? UILayoutPriority(rawValue: 1000) : UILayoutPriority(rawValue: 800)
    width2.priority = width2.priority.rawValue < 1000 ? UILayoutPriority(rawValue: 1000) : UILayoutPriority(rawValue: 800)
}

// Priority는 구조체로 되어있기 때문에 아래와 같이 적용해야 함
// 첫 번째 길이 Size Inspector에서 Priority를 999으로 변경함
// 첫 번째 길이 Size Inspector에서 Priority를 800으로 변경함

@IBAction func togglePriority(_ sender: Any) {
    width1.priority = width1.priority.rawValue < 999 ? UILayoutPriority(rawValue: 999) : UILayoutPriority(rawValue: 800)
    width2.priority = width2.priority.rawValue < 999 ? UILayoutPriority(rawValue: 999) : UILayoutPriority(rawValue: 800)
}
---- 

===== 상태바 밝은 테마로 바꾸기

[source, swift]
----
override var preferredStatusBarStyle: UIStatusBarStyle {
    return UIStatusBarStyle.lightContent
}
----

===== 업스케일링, 다운 스케일링
* 업스케일링: 고화질 -> 저화질
* 다운 스케일링: 저화질 -> 고화질
* 이미지 축소나 확대로 인한 계산은 오래된 기기에 부담을 줄 수 있음. 그래서 앱 슬라이싱 개념이 나옴

===== iOS Fonts
* http://www.sirochro.com/note/objc-ios7-font-sample/[iOS Fonts]

===== view.layer.masksToBounds, view.clipsToBounds 
* true 일 때 내용과 Subview들이 현재 View 테두리 기준으로 잘림. 기본값 false

===== ViewController 프로그래밍 간단 팁
* 한 개의 View에서 나타나는 모든 View들은 해당 View를 소유하고 있는 ViewController에서 제어해야 함

===== CATransaction
* http://seorenn.blogspot.com/2017/02/calayer-animation-core-animation.html[CALayer Animation (Core Animation)]
* 애니메이션이 완료되었을 때 뭔가를 하고 싶은 경우. Completion Handler 또는 Completion Block

[source, swift]
----
CATransaction.begin()

let animation = CABasicAnimation(keyPath: ...)
...
CATransaction.setCompletionBlock {
  print("Animation Finished")
}

layer.add(animation, forKey: "completion handler test")

CATransaction.commit()
----

===== 최상위 ViewController 찾아가는 방법

[source, swift]
----
// UIApplication.shared.keyWindow?.rootViewController 응용
// https://qiita.com/Simmon/items/80dbf50bc85c527f10f3

extension UIApplication {
    class func topViewController(controller: UIViewController? = UIApplication.shared.keyWindow?.rootViewController) -> UIViewController? {
        if let navigationController = controller as? UINavigationController {
            return topViewController(controller: navigationController.visibleViewController)
        }

        if let tabController = controller as? UITabBarController {
            if let selected = tabController.selectedViewController {
                return topViewController(controller: selected)
            }
        }

        if let presented = controller?.presentedViewController {
            return topViewController(controller: presented)
        }

        return controller
    }
}
----

===== LocationManager 작동하게 하기 
* http://seorenn.blogspot.com/2014/11/ios-8-locationmanager.html[iOS 8 이상에서 LocationManager 가 작동 하지 않는 경우]
* info.plist 수정
** NSLocationWhenInUseUsageDescription => 앱이 활성화 되어 있는 도중에만 위치서비스를 이용하는 경우
** NSLocationAlwaysUsageDescription => 앱이 백그라운드에서도 위치서비스를 계속 이용해야 하는 경우
* 코드 추가 

[source, swift]
----
self.locationManager = CLLocationManager()

let versionString = UIDevice.currentDevice().systemVersion as NSString
let version = versionString.floatValue
if version >= 8.0 {
    // 앱이 활성화 되어 있는 동안에만 위치서비스를 이용하는 경우
    self.locationManager.requestWhenInUseAuthorization()

    // 혹은 백그라운드에서도 위치서비스를 이용해야 하는 경우
    self.locationManager.requestAlwaysAuthorization()
}
----

===== WWDC 2018 영상
* http://rhammer.tistory.com/301[WWDC 2018 관심 영상 리스트]

===== UIGraphicsGetImageFromCurrentImageContext
* http://seorenn.blogspot.com/2014/02/ios-uiimage-export.html[그림을 그려서 UIImage로 Export 시키기]
* https://developer.apple.com/documentation/uikit/1623924-uigraphicsgetimagefromcurrentima[UIGraphicsGetImageFromCurrentImageContext]

===== UIGraphicsGetCurrentContext
* https://developer.apple.com/documentation/uikit/1623918-uigraphicsgetcurrentcontext[UIGraphicsGetCurrentContext]


===== setNeedsDisplay, setNeedsLayout, layoutIfNeeded, displayIfNeeded, layoutSubviews
* https://zeddios.tistory.com/359[View/레이아웃 업데이트 관련 메소드]
* https://soulpark.wordpress.com/tag/layoutsubviews-호출시점/[layoutSubviews 메서드 호출 시점]

===== String 밑줄 끗기

[source, swift]
----
extension String {
    func attachImage(resourceName: String, bounds: CGRect) -> NSMutableAttributedString {
        let attributedString = NSMutableAttributedString(string: "")
        let imageAttachment = NSTextAttachment()
        imageAttachment.bounds = bounds
        imageAttachment.image = UIImage(imageLiteralResourceName: resourceName)
        attributedString.append(NSAttributedString(attachment: imageAttachment))
        attributedString.append(NSAttributedString(string: " \(self)"))
        return attributedString
    }

    func throughStrikeWithImage(imageResourceName: String, imageBounds: CGRect) -> NSMutableAttributedString {
        let attributedString = attachImage(resourceName: imageResourceName, bounds: imageBounds)
        let range = NSRange(location: 0, length: attributedString.length)
        attributedString.addAttribute(NSStrikethroughStyleAttributeName, value: 2, range: range)
        return attributedString
    }
    
    var throughStrike: NSMutableAttributedString {
        let attributedString = NSMutableAttributedString(string: self)
        let range = NSRange(location: 0, length: attributedString.length)
        attributedString.addAttribute(NSStrikethroughStyleAttributeName, value: 2, range: range)
        return attributedString
    }
}
----

===== Image Slicing, Thinning
* https://medium.com/@vikaskore/bitcode-slicing-odrs-app-thinning-7c4b294ddec3[Bitcode, Slicing, ODRs, App Thinning]

===== Colors in XCode
* https://medium.com/@volbap/working-efficiently-with-colors-in-xcode-bc4c58b16f9a[Working efficiently with colors in Xcode]

===== Storyboard References
* https://useyourloaf.com/blog/refactoring-with-storyboard-references/[Refactoring with Storyboard references]
* https://medium.com/@leandromperez/avoiding-segue-identifiers-in-storyboards-2f582f85b3c1[How to avoid Segue Identifiers in Storyboards]

===== Shadow
* https://www.swiftlemma.com/2017/08/better-shadow-performance-on-views/[Better Shadow Performance on Views]
* https://stackoverflow.com/questions/29126271/swift-draw-shadow-to-a-uibezier-path[Drawing shadow to a UIBezier Path]

===== Concurrency Programming Guide
* https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091-CH1-SW1[Concurrency Programming Guide]

===== Frame, Bounds 차이
* https://zeddios.tistory.com/203[1]
* https://zeddios.tistory.com/m/231?category=682195[2]
* https://zeddios.tistory.com/m/242?category=682195[frame.height vs frame.size.height]

===== UIWindow, UIView
* https://zeddios.tistory.com/m/283?category=682195[UIWindow, UIView]
* https://zeddios.tistory.com/m/362?category=682195[UIView, NSView 차이]

===== 최신 버전 업데이트 하기
* https://zeddios.tistory.com/m/372?category=682195[최신버전 확인하기]

===== App에서 웹페이지 여는 방법

[source, swift]
----
// 사파리 앱 열기
UIApplication.shared.canOpenURL(url) else { return }
UIApplication.shared.open(url, options: [:], completionHandler: nil)

// WKWebView 이용
// WKWebView는 info.plist NSAppTransportSecurity 추가
----

===== 키워드 정리
* Sandbox
* FileManager, Bundle
* UIResponder
* hitTest