= Observer Pattern

===== 설명
* 객체의 상태가 바뀌면 그 객체를 의존하는 다른 객체들한테 연락이 가고 내용이 갱신함
* Push 알림이 필요한 곳에서 사용함
* 모델과 컨트롤러가 직접 참조하는 경우 발생하는 문제점
** 직접 참조한 객체으로만 테스트가 가능함
** 모델이 바꿔치기 될 때 컨트롤러에 변경사항이 일어남 => 수정해야 할 부분이 늘어남
* Loose Coupling
** Observer는 언제든지 새로 추가 할 수 있음
** 새로운 형식의 Observer를 추가하려고 할 때도 주제를 전혀 변경할 필요가 없음
** 주제와 옵저버는 서로 독립적으로 재사용 할 수 이음
** 주제나 옵저버가 바뀌더라도 서로에게 영향을 미치지 않음

===== 구현

[source, swift]
----
protocol Observer {
    var id: Int { get }
    func update()
}

class BinaryObserver: Observer {
    var id = Int()
    
    init(id: Int) {
        self.id = id
    }
    
    func update() {
        print("Binary: \(String(subject.number, radix: 2))")
    }
}

class OctalObserver: Observer {
    var id = Int()
    
    init(id: Int) {
        self.id = id
    }
    
    func update() {
        print("Octal: \(String(subject.number, radix: 8))")
    }
}

class Subject {
    private var observerArray = [Observer]()
    private var _number = Int()
    
    var number: Int {
        set {
            _number = newValue
            notify()
        }
        get {
            return _number
        }
    }
    
    func attachObserver(observer: Observer) {
        observerArray.append(observer)
    }
    
    func removeObserver(observer: Observer) {
        observerArray = observerArray.filter{ $0.id != observer.id }
    }
    
    private func notify() {
        for observer in observerArray {
            observer.update()
        }
    }
}

let subject = Subject()

let binary = BinaryObserver(id: 1)
let octal = OctalObserver(id: 2)

subject.attachObserver(observer: binary)
subject.attachObserver(observer: octal)
subject.number = 15
subject.removeObserver(observer: binary)
subject.number = 2
subject.number = 1
subject.attachObserver(observer: binary)
subject.number = 2
subject.number = 3
----

=== 참고
* https://medium.com/99ridho/swift-design-pattern-observer-pattern-fc009b783d19[Swift Design Pattern: Observer Pattern]